#!/usr/bin/env node
/*
 * Copyright (c) 2012 Kaerus, Anders Elo <anders @ kaerus com>.
 
 * Permission is hereby granted, free of charge, to any person obtaining a 
 * copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation 
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 * DEALINGS IN THE SOFTWARE.
 */
var arango = require('arango.client')
  , crypto = require('crypto')
  , util = require('util')
  , path = require('path')
  , fs = require('fs')
  , data, file;

function show_help() {
  console.log("arangodep v0.1 by Anders Elo <anders @Â kaerus com>.");
  console.log("Command: arangodep <options> <source> <destination>");
  console.log("Options:");
  console.log("\t--remove  \tDelete content");
  console.log("\t--expires \tExpiry date on index");
  console.log("\t--download\tDownload content");
  console.log("\t--upload  \tUpload content");
  console.log("\t--force   \tUse the force");
  console.log("\t--module  \tProcess module");

  process.exit(0);
}  

if( process.argv.length < 3 ) 
  show_help();

var execute = {  server: null,
              file: null,
              directory: null,
              remotedir: "",
              command: ""
            };

var file_list = {};

for(var i = 2, options; option = process.argv[i]; i++)
{
    switch(option) {
      case '--remove': 
        execute.command = "remove";
        break;
      case '--expires': 
        execute.expiry = new Date(Date.parse(process.argv[++i],"yyyy-MM-dd HH:MM:SS"));
        break;
      case '--download': 
        execute.server = process.argv[++i];
        execute.command = "download";
        break;
      case '--upload': 
        file = process.argv[++i].replace(/\/$/,'');
        execute.command = "upload";
        break;
      case '--watch': execute.command = "watch";
        break;     
      default:
        if(!file) file = option.replace(/\/$/,'');
        else if(!execute.server) execute.server = option;
        break;
    }
}

try {
  var stat = fs.statSync(file);
  /* determine the type of file */
  if(stat.isDirectory()) { 
    execute.directory = file;
  }  
  else if(stat.isFile()) execute.file = file;
  if(execute.command === 'watch') {
      /* get files .index on watch */
      var update_file = execute.directory + '/.index'; 
      try {
        file_list = JSON.parse(fs.readFileSync(update_file));
        console.log("File list:", util.inspect(file_list) );
        execute.server = file_list.remote;
      } catch(e) {
        console.log("Index file error:", e.message );
        process.exit(e.code);
      }   
  }
} catch(e) {
  if(execute.command === 'download') {
    /* create download directory */
    try {
      fs.mkdirSync(file);
    } catch(e) {
      console.log("mkdir error:", e.message);
      process.exit(e.code);
    } 
      /* set download directory */
      execute.directory = file;
      execute.file = null;
  } else {
    console.log("File error:", e.message);
    process.exit(e.code);
  }  
}



/* configure the arango client */
db = new arango.Connection(execute.server);
var x = db.config.name.split(':');
db.config.name = x[0]; 
execute.remotedir = x[1].replace(/^\//,'').replace(/\/$/,'');


if(execute.command === 'watch') {
  console.log("Watch: ", util.inspect(execute) );
}

file_list = {remote:execute.server,basedir:execute.remotedir,paths:[],files:[]};


if(execute.command === 'download') {
  db.key.get(execute.remotedir+'/.index',function(err,ret,hdr){
    if(err) {
      console.log("Failed to get .index, error(%s):", err, ret, hdr );   
    } else {
      try {
        file_list = JSON.parse(ret);
        fs.writeFile(execute.directory+'/.index',JSON.stringify(file_list),function(err){
          if(err) {
            console.log("Failed to create .index: ", err);
            process.exit(err);
          } else {
            download_files(file_list,execute.directory,db);
          }
        });
      } catch(e) {
        console.log("Failed to retrieve .index:", e.message);
        process.exit(e.code);
      }
    }   
  });
}

if(execute.command === 'upload') {
  /* upload directory & subdirs */
  if(execute.directory) {
    var readFiles = function(dir,base) {
      var files = fs.readdirSync(dir), extname;
      for(x in files) {
        try {
          var file = dir+'/'+files[x]
            , basepath = base+'/'+files[x];
          stat = fs.statSync(file);
          if(stat.isDirectory()) {
            file_list.paths.push(basepath);
            readFiles(file,basepath);
          } else if(stat.isFile()) {
            extname = path.extname(file);
            switch(extname) {
               case '.html':
               case '.css': 
               case '.js':
               case '.png':
               case '.gif':
               case '.jpg':
               case '.ico':
                 upload_file(file,execute.remotedir+basepath,db);
                 file_list.files.push(basepath.replace(/^[\.\/]/,''));
               break;
               default: 
                 console.log("* Skipping file:",file);
               break;  
            }
            
          }  
        } catch(e) { 
            console.log("File error:", e.message); 
        } // try   
      } // for  
    } // readFiles()
    readFiles(execute.directory,"");
  } else if(execute.file) {
    upload_file(execute.file,"",db);
  }
  
  /* update .index */
  var expiry = new Date(2025,0,0);
  db.key.put(execute.remotedir+"/.index", 
        {expires:expiry}, JSON.stringify(file_list), 
          function(err,ret) {
            if(err) console.log("Files .index error(%s):", err, ret ); 
            else console.log("Files .index:", util.inspect(file_list));
          }); 
}  
  


function upload_file(file,dest,db) {
  var binary, data, extname, contentType = "text/html";

  try {
    data = fs.readFileSync(file);
  } catch(e) {
    console.log("File read error:", e.message);
    return;
  }  
  extname = path.extname(file);
  switch (extname) {
          case '.gif':          
          case '.png':          
          case '.jpeg': 
          case '.jpg': 
          case '.ico':
            contentType = 'image/' + extname.replace(/^[\.]/,'');
            binary = true;
            break;
          case '.js':   
            contentType = 'text/javascript';  
            compress = true; 
            break;
          case '.css':  
            contentType = 'text/css';         
            break;
          case '.svg':  
            contentType = 'image/svg+xml';    
            break;
  }
  var expiry = new Date(2025,0,0);
  var md5 = crypto.createHash('md5').update(data).digest('hex');  
  db.key.put(dest, {expires:expiry,extended:{contentType:contentType,md5:md5}},
            binary ? data.toString('base64') : data,function(err,ret){
              if(err) console.log("Write error(%s):", err, ret );
            }); 
}

function download_files(file_list,destdir,db) {  

   console.log(util.inspect(file_list) );
   
  /* create directory structure */
  for(var x in file_list.paths) {
    try {
      console.log("Creating directory:", destdir+file_list.paths[x]);
      fs.mkdirSync(destdir+file_list.paths[x]);
    } catch(e) {
      if(e.code !== 'EEXIST') {
        console.log("Mkdir failed(%s):", e.code, e.message);
        process.exit(e.code);
      }  
    }
  }
  
  file_list.files.forEach(function(file) {
    download_file(file_list.basedir,destdir,file,db);
  });
  
} 

function download_file(sourcedir,destdir,file,db) {
  var sourcefile = sourcedir+'/'+file
    , destfile = destdir+'/'+file;
  db.key.get(sourcefile).on('result',function(ret,hdr){
    console.log("Downloading %s (%s bytes)", sourcefile, ret ? ret.length : 0);
      try {
        var ext = JSON.parse(hdr['x-voc-extended']);
      } catch(e) {
        console.log("Failed to parse header:", e.message);
        ext = {contentType:"text/html"};
      } 
      switch(ext.contentType) {
            case 'image/gif':
            case 'image/png':
            case 'image/jpg':
            case 'image/jpeg':
            case 'image/ico':
              var bin = new Buffer(ret,'base64').toString('binary');
            default:
            break;
      }
      fs.writeFile(destfile,bin ? bin : ret, bin ? 'binary' : 'utf-8',function(e) {
        if(e) console.log("Failed to write file:",e);
      });        
  });   

}
