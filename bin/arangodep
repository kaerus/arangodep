#!/usr/bin/env node
/* 
 * Copyright (c) 2012 Kaerus (kaerus.com), Anders Elo <anders @ kaerus com>.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

var arango = require('arango.client')
  , util = require('util')
  , mime = require('mime')
  , path = require('path')
  , fs = require('node-fs')
  , deploy = {
      app: {command: process_app, brief: "deploy application"},
      store: {command: process_store, brief: "key-value file store"},
      module: {command: process_module, brief: "deploy modules"},
      route: {command: process_route, brief: "configure routing"}
    }, program, program_path, error
  , PSEP = process.platform === 'win32' ? '\\' : '/'
  , package = require("../package");

process.argv.shift(); 
program_path = process.argv.shift();
program = package.name; 

function help() {
  console.log(package.description + " version " + package.version);
  console.log("Created by " + package.author.name + " <"+package.author.email+">");
  console.log("Commands:");
  Object.keys(deploy).forEach(function(command){
    console.log("%s:",command.pad(-16),deploy[command].brief)
  });
  console.log("type '" + program + " <command> --help' for more information.");
  process.exit(0);
}  

/* returns a fixed width padded string */
String.prototype.pad = function(justify,chr) {
  var str, args, width = Math.abs(justify), chr = chr || ' ', a, b;
  
  args = this.split('');
  args.unshift(this.length);
  if(justify >= 0) args.unshift(0);
  else args.unshift(width-this.length); 

  str = new Array(width);
  /* apply padding from a to b */
  a = justify < 0 ? 0 : this.length;
  b = justify < 0 ? width-this.length : width;
  for(var i = a; i < b; i++) str[i] = chr; 
  
  Array.prototype.splice.apply(str,args);

  return str.join('');
}

/* returns unique array */
Array.prototype.unique = function() {
  var o = {}, i, l = this.length, r = [];
  for(i=0; i<l; i++) o[this[i]] = this[i];
  for(i in o) r.push(o[i]);
  return r;
};

/* apply replace on array */
Array.prototype.replaceString = function(r,w) {
  for(var l = this.length; l > 0; l--) {
    if(typeof this[l-1] === 'string')
      this[l-1] = this[l-1].replace(r,w);
  }  
}

function error(msg,code) {
  console.error(msg);
  process.exit(code||-1);
}

if(process.argv.length < 1) help();

try {
  deploy[process.argv[0]].command.call(null,process.argv);
} catch(err) {
  error(err);
} 

function isBinary(data,file) {

  if(file) {
    /* shortcut for well-known types */ 
    switch(path.extname(file)){ 
      case '.html':
      case '.htm':
      case '.js':
      case '.json':
      case '.java':
      case '.css':
      case '.txt':
      case '.md':
      case '.cpp':
      case '.hpp':
      case '.c':
      case '.h':
      case '.py':
        return false;
      case '.bin':
      case '.jpg':
      case '.jpeg':
      case '.png':
      case '.tiff':
      case '.gif':
      case '.ico':
      case '.exe':
      case '.mov':
      case '.mpg':
      case '.mpeg':
      case '.avi':
      case '.gz':
      case '.gzip':
      case '.zip':
      case '.tar':
      case '.dmg':
      case '.wav':
      case '.aiff':
      case '.mp3':
      case '.mp4':
      case '.ogg':
        return true;
    }
  }
  /* zero sized */
  if(!data || !data.length) 
    return false;

  /* use heuristics (same as git) */
  if(data.slice(0,data.length > 1024 ? 1024 : data.length-1).toString().indexOf('\u0000') < 0)  
    return false;
  
  return true;
}

/* traverses directory structure         */
/* and returns filepaths to handler      */
/* basepath is without initial directory */
/* todo: how to handle symlinks?         */
function traverseFiles(dir,callback,subdir){
  var files = fs.readdirSync(dir), 
      extname, realpath, basepath;    
  files.forEach(function(file){
    realpath = subdir ? dir+PSEP+file : dir+file;
    basepath = subdir ? subdir+PSEP+file : file;
    try {
      stat = fs.statSync(realpath);
    } catch(err) { error("Failed to read " + realpath + ": " + err.message ) }  
    /* traverse subdirs */
    if(stat.isDirectory()) {
      traverseFiles(realpath,callback,basepath);
    } else if(stat.isFile()) {
      callback(realpath,basepath);
    } else if(stat.isSymbolicLink()) {
      console.log("* Ignoring symlink", realpath);
    } else {
      console.log("* Ignoring", realpath);
    }    
  });    
}

/* reads connection url and returns connection */
/* adds basedir to connection object */
function arangoConnection(conn_url) {
  var x, connection = new arango.Connection(conn_url);
  /* strip out collection name */
  x = connection.config.name.split(':');
  if(x && x.length > 1) {
    connection.config.name = x[0];
    connection.basedir = x[1];
    if(path.extname(connection.basedir)) {
      connection.basedir = path.dirname(connection.basedir);
    }  
  } 
  return connection;
}

/* processes files, determines source and destination */
/* callback gets source + dest filepath,              */ 
/* remote connection and toLocal flag                 */ 
/* todo: needs some refactoring */
function processFiles(files,callback) {
  var toLocal = true, remote;

  /* get sources & destination */
  sources = files.splice(0,files.length-1);
  destination = files[0];

  /* determine if destination is local or remote */
  if(destination) {
    if(destination.match(/^(?:([A-Za-z]+):)/)){
      toLocal = false;
      remote = arangoConnection(destination); 
    }   
  } else {
    remote = arangoConnection();
    toLocal = false;
  }

  if(sources.length === 0 && !remote){
      remote = arangoConnection();
      sources.push(destination);
      toLocal = false;
  }

  sources.forEach(function(source){ 
    if(toLocal) { 
      /* destination is local */
      try {
        remote = arangoConnection(source); 
      } catch (err) {
        error("source invalid or unavailable");
      }     
      callback(source,destination,remote,toLocal);
    } else { 
      /* destination is remote */
      try { 
        stat = fs.statSync(source); 
      } catch(err){ error("source invalid " + err.message) }   
      if(stat.isDirectory()){
        if(source[source.length-1] !== '/') source+='/';
        traverseFiles(source,function(sourcefile,destfile){
          callback(sourcefile,destfile,remote,toLocal);
        });
      } else {
        /* destfile = sourcefile */
        destination = path.basename(source);
        callback(source,destination,remote,toLocal);
      } 
    } 
  });

  if(!sources || sources.length === 0) {
    callback(null,destination,remote,false);
  }
}


/* dummy deploy process for testing purposes */
function process_dummy(argv) {
  var command = argv.shift()
    , options = {}
    , files = [];

  function help() {
    console.log("Deploy dummy");
    console.log("Command:", program + ' ' + command + " <options> <sources> <destination>");
    console.log("Options:");
    console.log("-h --help".pad(16),"Shows this help" );
    process.exit(0);
  }

  if(argv.length < 1) help();

  for(i = 0; i < argv.length; i++) {
    switch(argv[i]) {
      case '-h':
      case '--help':
        help();
        break;
      default:
        files.push(argv[i]);
        break;
    }
  }

  processFiles(files,function(source,destination,remote,toLocal){
    
    if(toLocal) {
      console.log("Download %s to %s", source, destination);
    } else {
      console.log("Deploy %s to %s", source, destination);

    }
  });
  
} /* end of process_dummy */

/* Handles deployment to/from the arangodb key-value store */
function process_store(argv) {
  var command = argv.shift()
    , options = {}
    , files = [];
    

  function help() {
    console.log("Key-value store deployment");
    console.log("Command:", program + ' ' + command + " <options> <sources> <destination>");
    console.log("Options:");
    console.log("-h --help".pad(16),"Shows this help"); 
    console.log("-e --expiry".pad(16),"Set Expiry date 'yyyy-mm-dd HH:MM:SS'");
    console.log("-l --list".pad(16),"List files");
    console.log("-p --path".pad(16),"Files path");
    console.log("-c --create".pad(16),"Create collection");
    console.log("-o --options".pad(16),"Collection options");
    console.log("-d --delete".pad(16),"Delete files");
    process.exit(0);
  }

  if(argv.length < 1) help();

  for(i = 0; i < argv.length; i++) {
    switch(argv[i]) {
      case '-h':
      case '--help':
        help();
        break;
      case '-e':
      case '--expiry':
        options.expiry = new Date(Date.parse(argv[++i],"yyyy-MM-dd HH:MM:SS")); 
        console.log("Expiry date: ", options.expiry.toString()); 
        break;  
      case '-l':
      case '--list':
        options.list = true;
        break;
      case '-v':
      case '--view':
        options.view = true;
        break;  
      case '-p':
      case '--path':
        options.path = argv[++i];
        break;    
      case '-d':
      case '--delete':
        options.remove = true;
        break;  
      case '-c':
      case '--create':
        options.create = true;
        break;  
      case '-o':
      case '--options':
        options.create_options = JSON.parse(argv[++i]);
        break;  
      default:
        if(argv[i].match(/^--[a-z]+$/)){
          error("Invalid option "+argv[i]);
        }
        files.push(argv[i]);
        break;
    }
  }

  processFiles(files,function(source,dest,remote,toLocal){
    var data, destdir, destfile;
    if(toLocal) {
      /* get list of files from remote */
      remote.key.list(remote.basedir,function(err,ret){
        if(err) error("Failed list files: " + ret);
        ret.forEach(function(sourcefile){
          /* destfile is same as sourcefile without remote basedir */
          destfile = dest+sourcefile.replace('%20',' ').replace(remote.basedir,'');
          try{ 
            fs.statSync(destfile); 
          } catch(e) {
            try {
              destdir = path.dirname(destfile);
              fs.statSync(destdir);
            } catch(err){ 
              fs.mkdirSync(destdir,0777, true);
              console.log("Created directory", destdir);
            }
          }
          read_remote_write_local(sourcefile,destfile,remote);
        });
      });
    } else {
      if(options.list || options.remove){
        if(!remote.basedir && !options.path) error("Option path missing");
        remote.key.list(remote.basedir,function(err,ret){
          if(err) error("Failed to list files: " + ret);
          ret.forEach(function(file){
            if(options.view){
              remote.key.get(file,function(err,ret,hdr){
                if(err) error("Failed to get remote " + file + " :" + ret);
                console.log(hdr);
                console.log(ret);
              });
            } else if(options.remove) {
              remote.key.delete(file,function(err,ret){
                if(err) error("Failed to remove " + file + " :" + ret);
                console.log("Deleted " + file);
              });
            } else console.log(ret);  
          });
        });
      } else {  
        /* add remote basedir to destfile */
        if(remote.basedir)
          destfile = remote.basedir + '/' + dest;
        else destfile = dest;

        /* uri encode spaces since arangodb can't handle that */
        destfile = destfile.replace(' ','%20');

        read_local_write_remote(source,destfile,remote,options);  
      }
    }  
  });    


  function read_remote_write_local(source,dest,remote){
    remote.key.get(source).on('result',function(ret,hdr){
      try {
        if(isBinary(ret,dest)){
          console.log("BIN: %s (%s bytes)", dest, ret ? ret.length : 0);
          fs.writeFileSync(dest,new Buffer(ret,'base64').toString('binary'),'binary');
        } else {
          console.log("ASC: %s (%s bytes)", dest, ret ? ret.length : 0);
          fs.writeFileSync(dest,ret,'utf-8');
        } 
      } catch(err) { error("Failed to write file:", err.message) }
    });  
  }

  function read_local_write_remote(source,dest,remote,options) {
    var data, bin, extended = {}, options = {};
    
    if(options.create) {
      console.log("Creating collection ", remote.config.name);
      remote.collection.create().on('error', function(err){
        error("Collection create failed: " + err.message);
      }).on('result',store);
    } else store();    

    function store() {
      try {
        data = fs.readFileSync(source);
      } catch(err) { error("Failed to read file:", err.message) } 

      bin = isBinary(data,source);
      extended.contentType = mime.lookup(source);
      if(bin) extended["contentEncoding"] = "base64";
      if(typeof options.expiry === 'object') options.expires = options.expiry;
      options.extended = extended;
      remote.key.put(dest, options, 
            bin ? data.toString('base64') : data, function(err,ret) {
              if(err) error("Failed to deploy " + source + ": " + ret);
              else console.log("%s: %s (%s bytes)", bin ? "BIN" : "ASC", source, data.length);  
      });
    }  
  }
} /* end of process_store */



/* handles deployment of arangodb modules */
function process_module(argv) {
  var command = argv.shift()
    , options = {}
    , files = [];

  function help() {
    console.log("Module deployment");
    console.log("Command:", program + ' ' + command + " <options> <sources> <destination>");
    console.log("Options:");
    console.log("-h --help".pad(16),"Shows this help" );
    console.log("-p --path".pad(16),"Module path");
    console.log("-i --id".pad(16),"Module id");
    console.log("-a --autoload".pad(16),"Autoload module");
    console.log("-l --list".pad(16),"List modules");
    console.log("-v --view".pad(16),"View module");
    console.log("-s --search".pad(16),"Search modules");
    console.log("-f --force".pad(16),"Force with errors");
    console.log("-d --delete".pad(16),"Delete module");
    process.exit(0);
  }

  if(argv.length < 1) help();

  for(i = 0; i < argv.length; i++) {
    switch(argv[i]) {
      case '-h':
      case '--help':
        help();
        break;
      case '-p':
      case '--path':
        options.path = argv[++i];
        break;  
      case '-i':
      case '--id':
        options.id = argv[++i];
        break;  
      case '-l':
      case '--list':
        options.list = true;
        break; 
      case '-s':
      case '--search':
        options.search = true;
        break;  
      case '-d':
      case '-delete':
        options.remove = true;
        break;    
      case '-v':
      case '--view':
        options.view = true;
        break;     
      case '-a':
      case '--autoload':
        options.autoload = argv[++i] === 'true' ? true : false;
        break;  
      case '-f':
      case '--force':
        options.force = true;
        break;  
      default:
        files.push(argv[i]);
        break;
    }
  }

  processFiles(files,function(source,dest,remote,toLocal){
    var destfile;

    if(toLocal) {  
      /* get list of files from remote */
      remote.simple.list("_modules",{path:remote.basedir||options.path},function(err,ret){
        if(err) error("Modules not found: " + ret);
        if(ret.result) {
          ret.result.forEach(function(module){
            /* note: path must start with basedir */
            /* how is this done in arangodb ?     */
              if(module.path.indexOf(remote.basedir||options.path) === 0 || 
                (options.search && module.path.indexOf(options.path) >=0 )) {
                remote_module_write_local(module,dest,remote);
              }  
          });
        } else console.log("No modules at ", remote.basedir);
      });
    } else {
      if (options.remove) {
        if(!options.path && !options.id)
          error("Module path or id missing.");
        if(options.id){
          remote.document.delete(options.id,function(err,ret){
            if(err) error("Failed to delete " + options.id + ": " + ret);
            console.log("Deleted module " + options.id);
          });
        } else {
          remote.simple.first("_modules",{path:options.path},function(err,ret){
            if(err) error("Failed to delete " + options.path + ": " + ret);
            remote.document.delete(ret.document._id,function(err,ret){
              if(err) error("Failed to delete " + options.path + ": " + ret);
              console.log("Deleted module " + options.path);
            });
          });
        }  
      } else if(options.list || options.search || options.view) {
          if(options.id) {
            remote.document.get(options.id,function(err,ret){
              if(err) error("Failed to read module: " + ret);
              print_module_if(ret,remote.basedir,options.path,options.view);
            });
          } else {
            remote.simple.list("_modules",{path:remote.basedir},function(err,ret){
              if(err) error("Modules not found: " + ret);
              ret.result.forEach(function(module){
               print_module_if(module,remote.basedir,options.path,options.view);   
              });
            });
          }    
      } else { 
        if(!options.path && !remote.basedir)
          error("Module path option missing.");
        if(remote.basedir)
          dest = remote.basedir + '/' + path.basename(dest);
        else dest = options.path;
        read_local_write_remote(source,dest,remote,options); 
      }
    }
  });

  function print_module_if(module,match,search,details){
    var content = module.content;
    delete module.content;
    if((!match && !search) || module.path.indexOf(match) === 0 || search && module.path.indexOf(search) >= 0) {
      console.log("%j", module);
      if(details) console.log(content);
    }
  }

  function remote_module_write_local(module,dest,remote){
    var destdir;

    destfile = dest+module.path.replace(remote.basedir,'');
    try{ 
      fs.statSync(destfile); 
    } catch(e) {
      try {
        destdir = path.dirname(destfile);
        fs.statSync(destdir);
      } catch(err){ 
        fs.mkdirSync(destdir,0777, true);
        console.log("Created directory", destdir);
      }
    }

    try{
      fs.writeFileSync(destfile,module.content,'utf-8');
      console.log("Downloaded %s (%s bytes)", destfile, module.content.length);
    } catch(err){ 
        error("Failed to create file: " + err.message);
    }    
  }

  function read_local_write_remote(source,dest,remote,options){
    var ESparser = require('esprima'), syntax, _module;

    try {
      data = fs.readFileSync(source).toString();
    } catch(err) { error("Failed to read file: ",err.message); }

    if(isBinary(data,source)) 
      error("Binary modules are not allowed");

    /* catch syntax errors */
    try {
      syntax = ESparser.parse(data);
    } catch(e) {
      if(options.force) {
        syntax = JSON.stringify(e,null,2);
        console.log("Warning: Deploying with validation errors at", syntax);
      } else error("Module contained errors at " + syntax);
    }
    /* todo: analyse syntax */

    _module = {path:dest,content:data};
    if(options.autoload) _module.autoload = true;
    else if(options.autoload === false) _module.autoload = false;

    /* check if module exists */
    remote.simple.first("_modules",{path:dest},function(err,ret){
      if(err){
        /* no module found */
        remote.document.create("_modules",_module,function(err,ret){
          if(err) error("Failed to deploy module: " + ret);
          console.log("Deployed module %s to %s", source, dest); 
        });
      } else {
        /* update existing */
        remote.document.put(ret.document._id,_module,function(err,ret){
          if(err) error("Failed to update module: " + ret);
          console.log("Updated module %s to %s", source, dest);
        });
      } 
    });
    
  }
  
} /* end of process_module */

/* dummy deploy process for testing purposes */
function process_route(argv) {
  var command = argv.shift()
    , options = {}
    , files = []
    , remote, matched;

  function help() {
    console.log("Deploy action routing");
    console.log("Command:", program + ' ' + command + " <options> <server>");
    console.log("Options:");
    console.log("-h --help".pad(16),"Shows this help" );
    console.log("-u --url".pad(16),"Url to match");
    console.log("-a --action".pad(16),"Action controller");
    console.log("-c --constraint".pad(16),"Url constraints");
    console.log("-o --controller".pad(16),"Specific controller");
    console.log("-p --prefix".pad(16),"Prefix controller");
    console.log("-x --do".pad(16),"Do controller method");
    console.log("-l --list".pad(16),"List routes");
    console.log("-v --view".pad(16),"View routing table");
    console.log("-i --id".pad(16),"Route id");
    console.log("-d --delete".pad(16),"Delete route");
    console.log("-r --reload".pad(16),"Reloads routing table");
    process.exit(0);
  }

  if(argv.length < 1) help();

  for(i = 0; i < argv.length; i++) {
    switch(argv[i]) {
      case '-h':
      case '--help':
        help();
        break;
      case '-u':
      case '--url':
        options.url = argv[++i];
        break;
      case '-a':
      case '--action':
        options.action = argv[++i];
        break;
      case '-c':
      case '--constraint':
        options.constraint = argv[++i];
        break;      
      case '-p':
      case '--prefix':
        options.prefix = true;
        break;  
      case '-d':
      case '--delete':
        options.remove = true;
        break;  
      case '-l':
      case '--list':
        options.list = true;
        break;  
      case '-v':
      case '--view':
        options.view = true;
        break;  
      case '-i':
      case '--id':
        options.id = argv[++i];
        break;  
      case '-o':
      case '--controller':
        options.controller = argv[++i];
        break;
      case '-x':
      case '--do':
        options.do = argv[++i];
        break;      
      case '-r':
      case '--reload':
        options.reload = true;
        break;   
      default:
        files.push(argv[i]);
        break;
    }
  }

  remote = new arango.Connection(files[files.length-1]);

  if(options.view) {
    remote.admin.routes(function(err,ret){
      if(err) error("Failed to list routes: " + ret);
      delete ret.error;
      delete ret.code;
      /* todo: make output easier to read... */
      console.log(JSON.stringify(ret, null, 2));
    });
  } else if(options.id){
    remote.document.get(options.id,function(err,route){
      if(err) error("Route not found: " + route);
      if(options.list) {
        console.log(route);
      } else add_route(remote,options,route);  
    });
  } else if(options.url || options.action || options.list){
    remote.simple.list("_routing",{url:true},function(err,ret){
      var url, action, m1, m2;
      if(err) error("List routings failed:" + ret);
      if(ret.result){
        ret.result.forEach(function(route){
          if(options.url) {
            url = (typeof route.url.match === 'string') ? route.url.match : route.url;   
          } 
          if(options.action) {
            action = (typeof route.action.prefixController === 'string') ? route.action.prefixController :
                      (typeof route.action.controller ==='string') ? route.action.controller : route.action;
          }
          m1 = url && url.indexOf(options.url) >= 0;
          m2 = action && action.indexOf(options.action) >=0;  
          if((url && action && m1 && m2)||(url&&!action&&m1)||(!url&&action&&m2) ) {
            if(!options.list) {
              add_route(remote,options,route);
            } else {
              console.log(route);
            }  
            matched = true;
          } 
        });
        if(!matched&&!options.remove){
          if(!options.list) {
            add_route(remote,options,null);
          } else if(!options.url&&!options.action){
            console.log(ret.result);
          } else {
            if(options.url)
              console.log("No route found for url: " + options.url);
            if(options.action)
              console.log("No route found for action: " + options.action);
          }  
        }
      }
    });
  }

  if(options.reload) {
    remote.admin.routesReload(function(err,ret){
      if(err) error("Failed to reload routing: " + ret);
      else console.log("Routes reloaded");
    });
  }     
  

  function add_route(remote,options,route){
    if(!route) {
      if(!options.url) error("Missing --url option");
    }

    /* merge route data */
    var doc = {url:options.url||route.url,action:options.action||(route ? route.action:"")};

    if(options.constraint){
      try {
        options.constraint = JSON.parse(options.constraint);
      } catch(e) {
        try {
          options.constraint = JSON.parse('{'+options.constraint+'}');
        } catch(e){
          error("Invalid constraint" + e.message);
        }
      }  
      if(typeof doc.url === 'string')
        doc.url = {match:doc.url,constraint:options.constraint};
      else 
        doc.url.constraint = options.constraint;
    }

    if(options.do) {
      if(typeof doc.action === 'string')
        doc.action = {controller:doc.action,do:options.do};
      else 
        doc.action.do = options.do;
    }

    if(options.controller){
      if(typeof doc.action === 'string')
        doc.action = {controller:options.controller};
      else {
        doc.action.controller = options.controller;
      }
    }

    if(options.prefix) {
      if(typeof doc.action === 'string')
        doc.action = {prefixController:doc.action};
      else {
        doc.action.prefixController = options.action;
        delete doc.action.controller;
      }
    }

    if(!route) {
      remote.document.create("_routing",doc,function(err,ret){
        if(err) error("Failed to create route:" + ret);
        console.log("Route added:", JSON.stringify(doc));  
      });
    } else if(options.remove) {
      remote.document.delete(route._id,function(err,ret){
        if(err) error("Failed to remove route: " + ret);
        console.log("Route deleted:", JSON.stringify(route));  
      });
    }
    else {
      remote.document.put(route._id,doc,function(err,ret){
        if(err) error("Failed to update route: " + ret);
        console.log("Route updated:", JSON.stringify(doc));  
      });
    }  
  }

} /* end of process_route */

/* deploy application */
function process_app(argv) {
  var command = argv.shift()
    , options = {modules:[], routes:[], store: []}
    , files = [], sourcedir, remotehost, destdir, index
    , now = new Date().toISOString()
    , banner = program + " v" + package.version + " " + now;

  function help() {
    console.log("Deploy application");
    console.log("Command:", program + ' ' + command + " <options>");
    console.log("options".pad(16),"arguments".pad(16),"description");
    console.log("-h --help".pad(16),"".pad(16),"Shows this help" );
    console.log("-c --create".pad(16),"<app>".pad(16),"Create application stub");
    console.log("-n --name".pad(16),"<name>".pad(16),"Set or change name"); 
    console.log("-a --add".pad(16),"<file|directory>".pad(16),"Add file");
    console.log("-r --remote".pad(16),"<remote>".pad(16),"Set remote (http://hostname/collection:basedir)");
    console.log("-i --init".pad(16),"".pad(16),"Initialize remote");
    console.log("-f --force".pad(16),"".pad(16),"Force update");

    process.exit(0);
  }

  if(argv.length < 1) help();

  for(i = 0; i < argv.length; i++) {
    switch(argv[i]) {
      case '-h':
      case '--help':
        help();
        break;
      case '-m':
      case '--module':
        options.modules.push(argv[++i].split(' '));
        break;
      case '-r':
      case '--route':
        options.routes.push(argv[++i].split(' '));
        break;    
      case '-c':
      case '--create':
        options.create = true;
        break;    
      case '-n':
      case '--name':
        options.name = argv[++i];
        break;  
      case '-a':
      case '--add':
        options.add = true;
        break;  
      case '-p':
      case '--push':
        options.push = true;
        break;
      case '-i':
      case '--init':
        options.init = true;
        break;  
      case '-r':
      case '--remote':
        options.remote = argv[++i];
        break;
      case '-f':
      case '--force':
        options.force = true;
        break;  
      default:
        files.push(argv[i]);
        break;
    }
  }

  /* creates application stub */
  if(options.create) {
    var sourcedir = files.shift();
    index = { remote:options.remote,
                    name:options.name||path.basename(sourcedir),
                    type:"web",
                    language:"js",
                    paths:[],
                    files:[],
                    created: now
                  };

    index.paths = [
      "/actions",        
      "/public",
      "/public/css",
      "/public/js"
    ]; 

    try {
      stat = fs.statSync(sourcedir);
    } catch(err) {
      try{
        fs.mkdirSync(sourcedir);
      } catch (err) {
        error("Failed to create " + sourcedir + ": " + err.message);
      }
    }
    /* check if sourcedir is empty */
    if(fs.readdirSync(sourcedir).length > 0)
      error("Application directory is not empty!");

    console.log("Creating application stub");
    var destdir;

    index.paths.forEach(function(file) {
      try {
        var destdir = sourcedir+file;
        fs.statSync(destdir);
      } catch(err) { 
        fs.mkdirSync(destdir,0777, true);
        console.log(destdir);
      }
    });
    console.log();
    console.log("Generating files");
    /* write application file stubs */
    write_file('public/index.html', "<!-- "+banner+" -->\n"+package.stubs.index);
    write_file('public/css/stylesheet.css',"/* "+banner+" */\n"+package.stubs.stylesheet);
    update_index(sourcedir);  
    error("done.",0);
  }          

  /* locate .index */
  var basedir = './', down = 6;
  while(down-- && !index) {
    try {
      index = JSON.parse(fs.readFileSync(basedir+'.index'));
    } catch (err) {
      if(basedir === './') basedir = '../';
      else basedir += '../';  
    }
  } 
  basedir = path.resolve(basedir);

  if(!index){
    error("Failed to locate .index");
  }  

  if(options.add) {
    var source = files.shift();
    console.log("adding ", source);
    try {
      stat = fs.statSync(source);
    } catch (err) {
      error("Failed to read " + source + ": " + err.message);
    }

    /* todo: refactor */
    if(stat.isDirectory()){
      var subdir = path.relative(basedir,path.resolve(path.dirname(source)));
      traverseFiles(source,function(file){
        index.paths.push(path.dirname(file));
        index.files.push(file);
      },subdir);
    } else if(stat.isFile()){
      var relpath = path.relative(basedir,path.resolve(source));
      index.paths.push(path.dirname(relpath));
      index.files.push(relpath);
    } else {
      error("Can not handle " + source);
    }
    update_index(basedir); 
  }

  if(options.name) {
    index.name = options.name;
    update_index(basedir);
  }

  if(options.remote) {
    index.remote = options.remote;
    update_index(basedir);
  }

  if(options.push) {
    var remote = arangoConnection(index.remote);
    
    if(!remote){
      error("Unspecified or invalid remote " + index.remote);
    }
  
    /* check for existing */
    remote.simple.first({"$key":remote.basedir+'/.index'}).on('result',function(res){
      var remote_index = JSON.parse(res.document["$value"]);
      if(!options.force && remote_index.updated === index.updated) {
        console.log("Already upto date");
      } else {
          /* update */
        push_index(basedir,remote);
      }
    }).on('error',function(err){
      /* create new */
      if(options.init||options.force) {
        push_index(base,remote,options.init ? {create:true} : undefined);
      } else error("Error on remote " + index.remote + ": " + err.message);    
    });
  }

  function write_file(file,data,encoding) {
      encoding = typeof encoding !== 'undefined' ? encoding  : 'utf8';

      var i = index.files.push(file);
      try{
        fs.writeFileSync(sourcedir+PSEP+index.files[i-1], data, encoding);
        console.log(file);
      } catch(err) {
        error("Failed to write: " + err.message);
      }
  }

  function update_index(dir){
    index.files.replaceString(/^[.\/]*/,'');
    index.paths.replaceString(/^[.\/]*/,'');
    index.files = index.files.unique();
    index.paths = index.paths.unique();
    index.updated = now;
    /* create index */
    try {     
      fs.writeFileSync(dir+PSEP+'.index', JSON.stringify(index, null, 2));
    } catch (err) {
      error("Failed to update .index: " + err.message);
    }
  }

  function push_index(basedir,remote,options) {
    options = options || {};
       
    if(options.create) {
      remote.collection.create().on('error', function(err){
        error("Create failed: " + err.message);
      }).on('result',store_index);
    } else store_index();    

    function store_index() {
      var extended = {};

      extended.contentType = mime.lookup('.json');
      remote.key.put(remote.basedir+'/.index',{extended:extended}, index, function(err,ret){
        if(err) error("Failed to write .index: " + ret);
        else {
          console.log("Updated .index");
          index.files.forEach(function(file){
            store_file(file);
          });
        }
      }); 
    }

    function store_file(file) {
      var data, bin, extended = {};

      try {
        data = fs.readFileSync(basedir+'/'+file);
      } catch(err) { error("Failed to read: " + err.message) } 

      bin = isBinary(data,file);
      extended.contentType = mime.lookup(file);
      if(bin) extended["contentEncoding"] = "base64";
      remote.key.put(remote.basedir+'/'+file, {extended:extended}, 
        bin ? data.toString('base64') : data, function(err,ret) {
          if(err) error("Failed to deploy " +file + ": " + ret);
          else console.log("%s: %s (%s bytes)", bin ? "BIN" : "ASC", file, data.length);  
      });
    }
  }
/*
  options.modules.forEach(function(module){
    module.unshift("module");
    module.push(remotehost);
    try{
        process_module.apply(null,module);
    } catch (err) {
      error("Failed to process module: " + err.message);
    }
  });
*/
/*
 options.routes.forEach(function(route){
    route.unshift("route");
    route.push(remotehost);
    try{
        process_route.apply(null,route);
    } catch (err) {
      error("Failed to process route: " + err.message);
    }
  });
*/

} /* end of process_application */