#!/usr/bin/env node
/*
 * Copyright (c) 2012 Kaerus, Anders Elo <anders @ kaerus com>.
 
 * Permission is hereby granted, free of charge, to any person obtaining a 
 * copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation 
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 * DEALINGS IN THE SOFTWARE.
 */

var arango = require('arango.client')
  , crypto = require('crypto')
  , util = require('util')
  , mime = require('mime')
  , path = require('path')
  , fs = require('node-fs')
  , deploy = {
      store: {command: process_store, brief: "deploy key-value"},
      module: {command: process_module, brief: "deploy module"}
    }, program;


function show_help() {
  console.log("Arango deployment tools v0.2 by Anders Elo <anders @ kaerus com>.");
  console.log("Commands:");
  Object.keys(deploy).forEach(function(command){
    console.log("%s:",command.pad(-16),deploy[command].brief)
  });
  console.log("type: 'arangodep <command> --help' for more information.");
  process.exit(0);
}  

/* returns a fixed width padded string */
String.prototype.pad = function(justify,chr) {
  var str, args, width = Math.abs(justify), chr = chr || ' ', a, b;
  
  args = this.split('');
  args.unshift(this.length);
  if(justify >= 0) args.unshift(0);
  else args.unshift(width-this.length); 

  str = new Array(width);
  /* apply padding from a to b */
  a = justify < 0 ? 0 : this.length;
  b = justify < 0 ? width-this.length : width;
  for(var i = a; i < b; i++) str[i] = chr; 
  
  Array.prototype.splice.apply(str,args);

  return str.join('');
}

process.argv.shift(); 
program = path.basename(process.argv.shift()); 

/*
if(!file) file = option.replace(/\/$/,'');
else if(!execute.server) execute.server = option;
*/

try {
  deploy[process.argv[0]].command.call(null,process.argv);
} catch(e) {
  console.log("Error(%s):", e.code, e.message);
  process.exit(e.code);
}  

function isBinary(file) {
  switch(path.extname(file)){
    case '.html':
    case '.htm':
    case '.js':
    case '.json':
    case '.css':
    case '.txt':
    case '.md':
      return false;
  }
  return true;
}

/* Handles deployment to/from the arangodb key-value store */
function process_store(argv) {
  var command = argv.shift()
    , options = {}
    , files = []
    , sources
    , destination
    , toLocal
    , stat
    , x;

  function help() {
    console.log("Command:", program + ' ' + command + " <options> <sources> <destination>");
    console.log("Options:");
    console.log("-h --help".pad(16),"Shows this help" );
    console.log("-e --expiry".pad(16),"Set Expiry date");
    process.exit(0);
  }

  for(i = 0; i < argv.length; i++) {
    switch(argv[i]) {
      case '-h':
      case '--help':
        help();
        break;
      case '-e':
      case '--expiry':
        options.expiry = new Date(Date.parse(argv[++i],"yyyyMMdd HH:MM:SS")); 
         
        console.log("Epiry: ", options.expiry.toString()); 
        break;  
      default:
        files.push(argv[i]);
        break;
    }
  }

  if(files.length < 2)
    throw {message: "source and destination required", code: -1};

  /* get sources & destination */
  sources = files.splice(0,files.length-1);
  destination = files[0];

  /* determine if destination is local or remote */
  if(destination.match(/^http?:s:/)) toLocal = false;
  else toLocal = true;

  /* process sources */
  sources.forEach(function(source){  
    if(toLocal) { 
      /* destination is local */
        try { 
          stat = fs.statSync(destination);
          if(!stat.isDirectory())
            throw {message:"destination must be a directory", code:-2} 
        }
        catch(e){
          try { fs.mkdirSync(destination,0777,true);
            console.log("Created directory", destination); 
          } catch(err) { throw err }  
        }   
      try {
        source = new arango.Connection(source);
        /* strip out collection name */
        x = source.config.name.split(':');
        source.config.name = x[0];
        /* keep basedir */
        source.basedir = x[1].replace(/^\//,'').replace(/\/$/,'');
      } catch (err) {
        throw {message:'source invalid or unavailable', code:-3 }
      }     

      source.key.list(source.basedir,function(err,ret){
        if(err) throw {message:ret,code:err}
        ret.forEach(function(file){
          remote_to_local(source,file,destination,options);
        });  
      });
    } else {   
      /* destination is remote */
      destination = new arango.Connection(destination);
      /* strip out collection name */
      x = destination.config.name.split(':');
      destination.config.name = x[0];
      /* keep basedir */
      destination.basedir = x[1].replace(/^\//,'').replace(/\/$/,'');  

      if(stat.isDirectory()){
        /* upload entire directory & subdirs */
        var readFiles = function(dir,base) {
          var files = fs.readdirSync(dir), extname;
          files.forEach(function(file){
            try {
             var filepath = dir+'/'+file
               , basepath = base+'/'+file;
              stat = fs.statSync(filepath);
              /* subdirs */
              if(stat.isDirectory()) {
                //file_list.paths.push(basepath);
                readFiles(filepath,basepath);
              } else if(stat.isFile()) {
                local_to_remote(filepath,basepath,destination,options);
              }  
            } catch(err) { throw err }    
          });  
        } // readFiles()
          readFiles(source,"");
      } else {
        local_to_remote(source,source,destination,options);
      } 
    } 

  });
  
  function local_to_remote(source,dest,remote,options) {
    var bin, data, contentType = mime.lookup(source), md5, destdir;

    if(!remote.basedir) 
        throw{message: "Destination basedir missing", code:-2}
    if(!(typeof options.expiry === 'object'))
        throw {message:"expiry date missing", code:-3}

    try {
      data = fs.readFileSync(source);
    } catch(err) { throw err } 

    /* create md5 fingerprint */
    md5 = crypto.createHash('md5').update(data).digest('hex');  
    destdir = remote.basedir+'/'+dest.replace(/^\.\//,'');
    bin = isBinary(source);
    remote.key.put(destdir, {expires:options.expiry,extended:{contentType:contentType,md5:md5}},
              bin ? data.toString('base64') : data,function(err,ret){
                if(err) throw {message:ret,code:err};
                else console.log("Deployed :%s (%s bytes) as %s file", destdir, data.length, bin ? 'binary' : 'text');  
              }); 
  }

  function remote_to_local(remote,source,dest,options) {
    /* note: this assumes we have remote basedir */
    var bin, destdir, destfile = dest + '/' + source.substr(source.indexOf('/')+1);  

    destdir = path.dirname(destfile);
    try{ 
      fs.statSync(destdir); 
    } catch(e) {
      try {
        fs.mkdirSync(destdir,0777, true);
      } catch(err){ throw err }
      console.log("Created directory", destdir);
    }

    remote.key.get(source).on('result',function(ret,hdr){
      console.log("Downloaded %s (%s bytes)", destfile, ret ? ret.length : 0);
        try {
          if(isBinary(source)){
            fs.writeFileSync(destfile,new Buffer(ret,'base64').toString('binary'),'binary');
          } else {
            fs.writeFileSync(destfile,ret,'utf-8');
          } 
        } catch(err) { throw err }       
    });   

  }
} /* end of process_store */

function process_module(argv) {

}