#!/usr/bin/env node
/*
 * Copyright (c) 2012 Kaerus, Anders Elo <anders @ kaerus com>.
 
 * Permission is hereby granted, free of charge, to any person obtaining a 
 * copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation 
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 * DEALINGS IN THE SOFTWARE.
 */

var arango = require('arango.client')
  , util = require('util')
  , mime = require('mime')
  , path = require('path')
  , fs = require('node-fs')
  , deploy = {
      store: {command: process_store, brief: "deploy files as key-values"},
      module: {command: process_module, brief: "deploy files as modules"},
      route: {command: process_route, brief: "manipulates routing"},
      dummy: {command: process_dummy, brief: "crash test dummy"}
    }, program, error
  , PSEP = process.platform === 'win32' ? '\\' : '/';  


function help() {
  console.log("Arango deployment tools v0.3.2 by Anders Elo <anders @ kaerus com>.");
  console.log("Commands:");
  Object.keys(deploy).forEach(function(command){
    console.log("%s:",command.pad(-16),deploy[command].brief)
  });
  console.log("type 'arangodep <command> --help' for more information.");
  process.exit(0);
}  

/* returns a fixed width padded string */
String.prototype.pad = function(justify,chr) {
  var str, args, width = Math.abs(justify), chr = chr || ' ', a, b;
  
  args = this.split('');
  args.unshift(this.length);
  if(justify >= 0) args.unshift(0);
  else args.unshift(width-this.length); 

  str = new Array(width);
  /* apply padding from a to b */
  a = justify < 0 ? 0 : this.length;
  b = justify < 0 ? width-this.length : width;
  for(var i = a; i < b; i++) str[i] = chr; 
  
  Array.prototype.splice.apply(str,args);

  return str.join('');
}

function error(msg,code) {
  console.error("Error:", msg);
  process.exit(code||-1);
}

process.argv.shift(); 
program = path.basename(process.argv.shift()); 

if(process.argv.length < 2) help();

try {
  deploy[process.argv[0]].command.call(null,process.argv);
} catch(err) {
  help();
} 

function isBinary(file) {
  switch(path.extname(file)){
    case '.html':
    case '.htm':
    case '.js':
    case '.json':
    case '.css':
    case '.txt':
    case '.md':
      return false;
  }
  return true;
}

/* traverses directory structure         */
/* and returns filepaths to handler      */
/* basepath is without initial directory */
/* todo: how to handle symlinks?         */
function traverseFiles(dir,callback,subdir){
  var files = fs.readdirSync(dir), 
      extname, realpath, basepath;    
  files.forEach(function(file){
    try {
      realpath = subdir ? dir+PSEP+file : dir+file;
      basepath = subdir ? subdir+PSEP+file : file;
      stat = fs.statSync(realpath);
      /* traverse subdirs */
      if(stat.isDirectory()) {
        traverseFiles(realpath,callback,basepath);
      } else if(stat.isFile()) {
        callback(realpath,basepath);
      }  
    } catch(err) { error("Failed to read file or directory:", err.message ) }    
  });    
}

/* reads connection url and returns connection */
/* adds basedir to connection object */
function arangoConnection(conn_url) {
  var x, connection = new arango.Connection(conn_url);
  /* strip out collection name */
  x = connection.config.name.split(':');
  if(x && x.length > 1) {
    connection.config.name = x[0];
    /* keep basedir & trim slashes */
    connection.basedir = x[1].replace(/^\//,'').replace(/\/$/,'');
  } 
  return connection;
}

/* processes files, determines source and destination */
/* callback gets source + dest filepath,              */ 
/* remote connection and toLocal flag                 */ 
/* todo: needs some refactoring */
function processFiles(files,callback) {
  var toLocal;

  /* TODO: ability to read from stdin and write to stdout */
  if(files.length < 2)
    error("source and destination required");

  /* get sources & destination */
  sources = files.splice(0,files.length-1);
  destination = files[0];

  /* determine if destination is local or remote */
  if(destination.match(/^(?:([A-Za-z]+):)/)) toLocal = false;
  else toLocal = true;
 
  sources.forEach(function(source){ 
    if(toLocal) { 
      /* destination is local */
      try {
        var remote = arangoConnection(source); 
      } catch (err) {
        error("source invalid or unavailable");
      }     
      callback(source,destination,remote,toLocal);
    } else {   
      /* destination is remote */
      var remote = arangoConnection(destination); 
      try { 
          stat = fs.statSync(source); 
        } catch(err){ error("source invalid " + err.message) }   
      if(stat.isDirectory()){
          /* upload entire directory & subdirs */
          traverseFiles(source,function(sourcefile,destfile){
            callback(sourcefile,destfile,remote,toLocal);
          });
      } else {
        /* destfile = sourcefile */
        destination = path.basename(source);
        callback(source,destination,remote,toLocal);
      } 
    } 
  });
}


/* dummy deploy process for testing purposes */
function process_dummy(argv) {
  var command = argv.shift()
    , options = {}
    , files = [];

  function help() {
    console.log("Deploy dummy");
    console.log("Command:", program + ' ' + command + " <options> <sources> <destination>");
    console.log("Options:");
    console.log("-h --help".pad(16),"Shows this help" );
    process.exit(0);
  }

  for(i = 0; i < argv.length; i++) {
    switch(argv[i]) {
      case '-h':
      case '--help':
        help();
        break;
      default:
        files.push(argv[i]);
        break;
    }
  }

  processFiles(files,function(source,destination,remote,toLocal){
    
    if(toLocal) {
      console.log("Download %s to %s", source, destination);
    } else {
      console.log("Deploy %s to %s", source, destination);

    }
  });
  
} /* end of process_dummy */

/* Handles deployment to/from the arangodb key-value store */
function process_store(argv) {
  var command = argv.shift()
    , options = {}
    , files = [];
    

  function help() {
    console.log("Key-value store deployment");
    console.log("Command:", program + ' ' + command + " <options> <sources> <destination>");
    console.log("Options:");
    console.log("-h --help".pad(16),"Shows this help" );
    console.log("-e --expiry".pad(16),"Set Expiry date 'yyyy-mm-dd HH:MM:SS'");
    process.exit(0);
  }

  for(i = 0; i < argv.length; i++) {
    switch(argv[i]) {
      case '-h':
      case '--help':
        help();
        break;
      case '-e':
      case '--expiry':
        options.expiry = new Date(Date.parse(argv[++i],"yyyy-MM-dd HH:MM:SS")); 
        console.log("Epiry date: ", options.expiry.toString()); 
        break;  
      default:
        files.push(argv[i]);
        break;
    }
  }


  processFiles(files,function(source,dest,remote,toLocal){
    var data, destdir, destfile;
    if(toLocal) {
      try { 
          stat = fs.statSync(dest);
          if(!stat.isDirectory())
            throw error("destination must be a directory"); 
        }
        catch(e){
          try { fs.mkdirSync(dest,0777,true);
            console.log("Created directory", dest); 
          } catch(err) { error("Failed to make directory:", err.message) }  
      }   
      /* get list of files from remote */
      remote.key.list(remote.basedir,function(err,ret){
        if(err) error("Failed list files: " + ret);
        ret.forEach(function(sourcefile){
          /* destfile is same as sourcefile without remote basedir */
          destfile = dest+sourcefile.replace(remote.basedir,'');
          try{ 
            fs.statSync(destfile); 
          } catch(e) {
            try {
              destdir = path.dirname(destfile);
              fs.statSync(destdir);
            } catch(err){ 
              fs.mkdirSync(destdir,0777, true);
              console.log("Created directory", destdir);
            }
          }
          read_remote_write_local(sourcefile,destfile,remote);
        });
      });
    } else {
      /* add remote basedir to destfile */
      if(remote.basedir)
        destfile = remote.basedir + '/' + dest;
      else destfile = dest;

      if(!(typeof options.expiry === 'object'))
        error("expiry date missing");
  
      read_local_write_remote(source,destfile,remote,options.expiry);  
    }  

  });    

  function read_remote_write_local(source,dest,remote){
    remote.key.get(source).on('result',function(ret,hdr){
      console.log("Downloaded %s (%s bytes)", dest, ret ? ret.length : 0);
      try {
        if(isBinary(source)){
          fs.writeFileSync(dest,new Buffer(ret,'base64').toString('binary'),'binary');
        } else {
          fs.writeFileSync(dest,ret,'utf-8');
        } 
      } catch(err) { error("Failed to write file:", err.message) }
    });  
  }

  function read_local_write_remote(source,dest,remote,expiry) {
    try {
      data = fs.readFileSync(source);
    } catch(err) { error("Failed to read file:", err.message) } 

    remote.key.put(dest, { 
          expires:expiry,
          extended:{contentType: mime.lookup(source)}
          }, isBinary(source) ? data.toString('base64') : data.toString(), function(err,ret) {
              if(err) error("Failed to update: " + ret);
              else console.log("Deployed %s (%s bytes)", dest, data.length);  
    }); 
  }
} /* end of process_store */



/* handles deployment of arangodb modules */
function process_module(argv) {
  var command = argv.shift()
    , options = {}
    , files = [];

  function help() {
    console.log("Module deployment");
    console.log("Command:", program + ' ' + command + " <options> <sources> <destination>");
    console.log("Options:");
    console.log("-h --help".pad(16),"Shows this help" );
    process.exit(0);
  }

  for(i = 0; i < argv.length; i++) {
    switch(argv[i]) {
      case '-h':
      case '--help':
        help();
        break;
      default:
        files.push(argv[i]);
        break;
    }
  }


  processFiles(files,function(source,dest,remote,toLocal){
    var destfile;

    if(toLocal) {
      try { 
          stat = fs.statSync(dest);
          if(!stat.isDirectory())
            throw error("destination must be a directory"); 
        }
        catch(e){
          try { fs.mkdirSync(dest,0777,true);
            console.log("Created directory", dest); 
          } catch(err) { error("Failed to make directory:", err.message) }  
      }   
      /* get list of files from remote */
      remote.simple.list("_modules",{path:remote.basedir},function(err,ret){
        if(err) error("Modules not found: " + ret);
        if(ret.result) {
          ret.result.forEach(function(module){
            /* note: path must start with basedir */
            /* how is this done in arangodb ?     */
            if(module.path.indexOf(remote.basedir) === 0)
              remote_module_write_local(module,dest,remote);
          });
        } else console.log("No modules at ", remote.basedir);
      });
    } else {
      /* add remote basedir to destfile */
      if(remote.basedir)
        destfile = remote.basedir + '/' + dest;
      else destfile = dest;

      read_local_write_remote(source,destfile,remote);
    }
  });

  function remote_module_write_local(module,dest,remote){
    var destdir;

    destfile = dest+module.path.replace(remote.basedir,'');
    try{ 
      fs.statSync(destfile); 
    } catch(e) {
      try {
        destdir = path.dirname(destfile);
        fs.statSync(destdir);
      } catch(err){ 
        fs.mkdirSync(destdir,0777, true);
        console.log("Created directory", destdir);
      }
    }

    try{
      fs.writeFileSync(destfile,module.content,'utf-8');
      console.log("Downloaded %s (%s bytes)", destfile, module.content.length);
    } catch(err){ 
        error("Failed to create file: " + err.message);
    }    
  }

  function read_local_write_remote(source,dest,remote){
    if(isBinary(source)) 
      error("Binary modules are not permitted");

    try {
      data = fs.readFileSync(source).toString();
    } catch(err) { error("Failed to read file:",err.message); }

    /* check if module exists */
    remote.simple.first("_modules",{path:dest},function(err,ret){
      if(err){
        /* no module found */
        remote.document.create("_modules",{path:dest,content:data},function(err,ret){
          if(err) error("Failed to deploy module: " + ret);
          else console.log("Deployed module %s to %s", source, dest); 
        });
      } else {
        /* update existing */
        remote.document.put(ret.document._id,{path:dest,content:data},function(err,ret){
          if(err) error("Failed to update module: " + ret);
          else console.log("Updated module %s to %s", source, dest);  
        });
      } 
    });
    
  }
  
} /* end of process_module */

/* dummy deploy process for testing purposes */
function process_route(argv) {
  var command = argv.shift()
    , options = {}
    , files = []
    , remote, updated;

  function help() {
    console.log("Deploy action routing");
    console.log("Command:", program + ' ' + command + " <options> <server>");
    console.log("Options:");
    console.log("-h --help".pad(16),"Shows this help" );
    console.log("-u --url".pad(16),"Url to match");
    console.log("-a --action".pad(16),"Action controller");
    console.log("-c --constraint".pad(16),"Url constraints");
    console.log("-l --list".pad(16),"List routes");
    console.log("-i --id".pad(16),"Route id");
    console.log("-r --remove".pad(16),"Remove route");
    process.exit(0);
  }

  for(i = 0; i < argv.length; i++) {
    switch(argv[i]) {
      case '-h':
      case '--help':
        help();
        break;
      case '-u':
      case '--url':
        options.url = argv[++i];
        break;
      case '-a':
      case '--action':
        options.action = argv[++i];
        break;
      case '-c':
      case '--constraint':
        options.constraint = argv[++i];
        break;      
      case '-r':
      case '--remove':
        options.remove = true;
        break;  
      case '-l':
      case '--list':
        options.list = true;
        break;  
      case '-i':
      case '--id':
        options.id = argv[++i];
        break;  
      default:
        files.push(argv[i]);
        break;
    }
  }

  remote = new arango.Connection(files[files.length-1]);
  if(options.id){
    remote.document.get(options.id,function(err,route){
      if(err) error("Route not found: " + route);
      add_route(remote,options,route);  
    });
  } else {
    remote.simple.list("_routing",{url:true},function(err,ret){
      if(err) error("List routing failed:" + ret);
      if(ret.result){
        ret.result.forEach(function(route){
          if(route.url == options.url || route.url.match === options.url) {
            if(!options.list) {
              add_route(remote,options,route);
            } else {
              console.log(route);
            }  
            updated = true;
          } 
        });
        if(!updated&&!options.remove){
          if(!options.list) {
            add_route(remote,options,null);
          } else {
            console.log(ret.result);
          }  
        }
      }
    });
  }     
  

  function add_route(remote,options,route){
    if(!route) {
      if(!options.url) error("Missing --url option");
      if(!options.action) error("Missing --action option");
    }

    /* merge route data */
    var doc = {url:options.url||route.url,action:options.action||route.action};

    if(options.constraint){
      if(typeof doc.url === 'string')
        doc.url = {match:doc.url,constraint:options.constraint};
      else 
        doc.url.constraint = options.constraint;
    }

    if(options.do) {
      if(typeof doc.action === 'string')
        doc.action = {controller:doc.action,do:options.do};
      else 
        doc.action.do = options.do;
    }

    if(!route && !options.remove) {
      remote.document.create("_routing",doc,function(err,ret){
        if(err) error("Failed to create route:" + ret);
        console.log("Route added: ", doc);  
      });
    } else {
      if(!options.remove){
        remote.document.put(route._id,doc,function(err,ret){
          if(err) error("Failed to update route: " + ret);
          console.log("Route updated: ", doc);  
        });
      } else {
        remote.document.delete(route._id,function(err,ret){
          if(err) error("Failed to remove route: " + ret);
          console.log("Route deleted: ", route);  
        });
      }
    }  
  }
} /* end of process_route */
